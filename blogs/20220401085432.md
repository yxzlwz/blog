---
title: C++快读快写极限优化模板
date: 2022-04-01 08:54:32
categories:
- 信息学竞赛
tags:
- C++
- 信息学竞赛
---

快读的原理很简单：由于C++输入输出中处理字符串的效率是处理数字的效率的不知多少倍（具体原因以本人能力难以解释）。

因此，在我们输入数据量较多且追求较高的程序算法效率时，可以依次读入字符，再根据输入顺序对字符进行运算（计算机执行加法乘法的速度还是很快的，在这里我们还可以使用位运算代替乘法）。

一般地，在我们比赛/刷题过程中，当输入数字数量超过 $5\times10^4$ 时，就建议大家使用快读来提高程序的执行效率。

快写原理与之类似，但是需要输出大量数据的情况较少，因此使用也较少。

特别地，注意以下两点：

- 对于128int类型的数据，标准输入输出无法处理，必须使用快读
- 为了我们快读快写的效率不被其它因素消磨掉，`inline` 必须要加，特别是用到递归调用的快写！

下面直接来看代码吧，未尽事宜都在注释里了

# 整数

#### 快读

```cpp
inline void read(int &x) {  // 返回类型必须为void，否则竞赛中Linux测评会报错，Windows没事
	x = 0;
	short flag = 1;
	char c = getchar();
    while(c < '0' || c > '9'){
    	// 此处如果只用if的话容易在数据不规范时出错，特别是cin和read混用
        if(c == '-')flag = -1;
        c = getchar();
    }
	while(c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);  // 48这个数字恰好往后10个数都可以使用位运算，可以写成二进制证明；位运算能用当然更好
		c = getchar();
	}
	x *= flag;
}

int main() {
	int a;
	read(a);
}
```

这样子直接存储到地址的方法是更优的，但是对于 `int` `short` 和 `long long` 类型之间的互通性差点意思。

#### 快写

```cpp
inline void write(int x)
{
    if(x < 0){
    	putchar('-');
		x = -x;
	}
    if(x > 9) 
		write(x / 10);
    putchar(x % 10 + '0');
}

int main() {
	int a = -123;
	write(a);
}
```

# 浮点型

#### 快读


#### 快写


