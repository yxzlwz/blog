import{_ as s,c as a,a as e,o as t}from"./app-Boikxu3H.js";const n="/assets/acba1da3b02e42f8c0300dac61aacf33-sKgk6Jcj.png",l="/assets/9a957bff1bb955d56d17b98773612c04-ZchLJ2W1.png",h="/assets/3124157087352f4670db60aaec53ec90-dK4BChMv.png",p="/assets/576e1ceb60d6ae2b521b225d022ace92-DA5ESUxD.png",k="/assets/18237844142958953fc9ea4d545f6585-BqRpz5y0.png",d="/assets/1b0b9ee981990376cdb3e968a4c36d55-CbzgbbRC.png",r="/assets/db073dcce6c4c5d2be58d4567de7ee5f-D5VbfTRC.png",g="/assets/913b1c1bcdf217d9595740ed632804e3-BRvM3QiZ.png",c={};function o(y,i){return t(),a("div",null,[...i[0]||(i[0]=[e('<blockquote><p>本文是对 《100 Go Mistackes：How to Avoid Them》一书的翻译。因翻译水平有限，难免存在翻译准确性问题，敬请谅解。更多内容请关注公众号--Go学堂</p></blockquote><p>对于Go研发人员来说，对于slice结构中的长度（length）和容量（capacity）经常混淆是很常见的。完全理解这两个概念对有效处理slice的核心操作是至关重要的。例如：对slice的初始化，使用append添加元素，拷贝元素或分隔slice等操作。否则，可能导致使用append操作切片时性能低下，甚至是内存泄露。</p><p>在Go语言中，slice的底层实现是数组，也就是说，切片的数据实际上是被存储在数组中的。如果后端的数组空间已经满了或是空数组，则slice结构体负责处理数组容量的扩容或缩容逻辑。</p><p>此外，slice的结构体中共拥有三个字段：</p><ul><li>一个指针，指向后端的数组，</li><li>一个length字段，代表该slice中包含的元素个数。</li><li>一个capacity（容量）字段，代表后端数组能够容纳的元素个数。</li></ul><p>我们通过两个例子来演示一下slice的结构。</p><p>首先，我们使用给定的长度和容量来初始化一个slice:</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-go"><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> :=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> make</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">([]</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 6</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // ①</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>① 第二个参数3代表长度（length），第三个参数6代表容量（capacity）</p><p>如下图所示：</p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>该切片创建了一个能够容纳6个元素（容量）的数组。同时，因为长度length被设置成了3，所以，Go仅仅初始化前3个元素。因为slice的元素是[]int类型，所以前3个元素用int的零值0来初始化。剩余的元素空间只被分配，但没有使用。</p><p>如果打印这个切片，将会得到如下结果：[0 0 0]。</p><p>如果我们设置s[1] = 1，那么，该切片的第2个元素将会被更新，但对该slice的长度和容量不会有任何影响。如下图所以：</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>但是，不允许访问切片长度（length）以外的元素，即使长度以外的内存空间也已经被分配了。例如，s[4] = 0 会引发panic：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-text"><span class="line"><span>panic:runtime error: index out of range [4] with length 3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>那么，我们该如何使用slice中剩余的空间呢？通过内建的append函数：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-go"><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> append</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>该操作将会往s切片中添加一个新的元素。该元素使用第一个图中灰色的元素块（即分配了空间但又没被使用的位置）来存储元素2。如下图所以：</p><figure><img src="'+h+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这时，slice的长度length从3变成了4，即该slice现在有4个元素。</p><p>那如果我们再多加入3个元素slice会发生什么？后端的数组空间会不会不足够大了？</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-go"><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> append</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> append</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 4</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> append</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">fmt</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们执行这部分代码，我们会注意到该slice依然能满足我们的需求：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-go"><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 3</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 4</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>因为数组是一个固定长度的结构，只能将元素4给存储进去。当我们想插入元素5时，该数组就已经满了，Go会创建另一个数组，并且空间大小是原来容量的2倍，然后将原数组中的所有元素都拷贝到新数组中去，再在新数组中插入元素5，如下图所示：</p><figure><img src="`+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>现在slice的的指针字段指向了新的数组。那原来的那个数组会怎么样呢？如果没有被引用，将会被GC进行回收。</p><p>下面，我们来看看对一个slice进行切分的影响：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-go"><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> :=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> make</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">([]</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 6</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // ①</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> :=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> s1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // ②</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>① 一个长度为3，容量为6的切片 ② 从索引1到3进行切分</p><p>如下图：</p><figure><img src="`+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>首先，s1被初始化成一个长度为3，容量为6的切片。当通过切分s1创建s2切片时，s1和s2的指针字段都指向同一个后端数组。但是，s2的第一个元素的索引是从数组的索引1开始的。因此，切片s2的长度和容量是和s1不同的：长度为2，容量为5.</p><p>如果我们更新s1[1]或s2[0]，那么对于后端数组来说，变更是一样的。因此，该变更对两个切片都是可见的，如图所示：</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>那，如果现在往s2中append一个元素会发生什么呢？会对s1有影响吗？</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-go"><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> append</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样，会将共享的数组进行修改，但只有s2的长度会发生改变，如图所示：</p><figure><img src="'+r+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>s1的长度依然是3，容量是6。因此，如果我们打印s1和s2，那么被加入的元素只对s2可见：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-text"><span class="line"><span>s1 = [0 1 0], s2 = [1 0 2]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在使用append时，理解这个行为会降低出错的概率。</p><p>最后一个需要注意的是，如果我们持续往s2中append元素，直到数组满了位置，会发生什么呢？ 我们再往s2中增加3个元素，直到将后端的数组填满，没有任何可用的空间：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-go"><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> append</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> append</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 4</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> append</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // ①</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>① 在该阶段，后端的数组就已经满了。</p><p>这段代码会导致创建另一个新的数组，如图所示：</p><figure><img src="`+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>注意，这时s1和s2分别指向了两个不同的数组。实际上，s1依然是一个长度为3，容量为6的切片，同时也有一些可用的buffer空间，因此，它依然是引用了最初的那个数组。同时，新创建的数组，会从s2的起始位置将数据拷贝到自己的空间上来。这也就是为什么新数组的第一个元素是1，而不是0的原因。</p><p>总之，切片中的length是该切片中当前已存储的元素个数，切片的容量是该切片指向的数组的元素个数。往一个满了的切片（切片长度=切片容量）中添加新元素会触发创建一个新的数组，并且新数组的容量是原来的2倍，该新数组会将原数组中的元素都拷贝过来，同时将slice中的指针更新到指向新数组。</p>',51)])])}const b=s(c,[["render",o]]),f=JSON.parse('{"path":"/article/4y7io53v/","title":"【转载】Go常见错误集锦之混淆slice中的长度(length)和容量(capacity) - Go切片make()初始化相关问题解惑","lang":"zh-CN","frontmatter":{"title":"【转载】Go常见错误集锦之混淆slice中的长度(length)和容量(capacity) - Go切片make()初始化相关问题解惑","createTime":"2021/10/28 21:29:25","tags":["转载"],"copyright":{"creation":"reprint","source":"https://zhuanlan.zhihu.com/p/413972333","author":"Go学堂","license":{"name":"未知","url":null}},"permalink":"/article/4y7io53v/","description":"本文是对 《100 Go Mistackes：How to Avoid Them》一书的翻译。因翻译水平有限，难免存在翻译准确性问题，敬请谅解。更多内容请关注公众号--Go学堂 对于Go研发人员来说，对于slice结构中的长度（length）和容量（capacity）经常混淆是很常见的。完全理解这两个概念对有效处理slice的核心操作是至关重要的。例如...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"【转载】Go常见错误集锦之混淆slice中的长度(length)和容量(capacity) - Go切片make()初始化相关问题解惑\\",\\"image\\":[\\"https://yxzl.dev/images/acba1da3b02e42f8c0300dac61aacf33.png\\",\\"https://yxzl.dev/images/9a957bff1bb955d56d17b98773612c04.png\\",\\"https://yxzl.dev/images/3124157087352f4670db60aaec53ec90.png\\",\\"https://yxzl.dev/images/576e1ceb60d6ae2b521b225d022ace92.png\\",\\"https://yxzl.dev/images/18237844142958953fc9ea4d545f6585.png\\",\\"https://yxzl.dev/images/1b0b9ee981990376cdb3e968a4c36d55.png\\",\\"https://yxzl.dev/images/db073dcce6c4c5d2be58d4567de7ee5f.png\\",\\"https://yxzl.dev/images/913b1c1bcdf217d9595740ed632804e3.png\\"],\\"dateModified\\":\\"2025-10-10T04:50:50.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://yxzl.dev/article/4y7io53v/"}],["meta",{"property":"og:site_name","content":"异想之旅のBlog"}],["meta",{"property":"og:title","content":"【转载】Go常见错误集锦之混淆slice中的长度(length)和容量(capacity) - Go切片make()初始化相关问题解惑"}],["meta",{"property":"og:description","content":"本文是对 《100 Go Mistackes：How to Avoid Them》一书的翻译。因翻译水平有限，难免存在翻译准确性问题，敬请谅解。更多内容请关注公众号--Go学堂 对于Go研发人员来说，对于slice结构中的长度（length）和容量（capacity）经常混淆是很常见的。完全理解这两个概念对有效处理slice的核心操作是至关重要的。例如..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://yxzl.dev/images/acba1da3b02e42f8c0300dac61aacf33.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-10T04:50:50.000Z"}],["meta",{"property":"article:tag","content":"转载"}],["meta",{"property":"article:modified_time","content":"2025-10-10T04:50:50.000Z"}]]},"git":{"createdTime":1758874804000,"updatedTime":1760071850000},"autoDesc":true,"filePathRelative":"tech/20211028212925.md","headers":[]}');export{b as comp,f as data};
