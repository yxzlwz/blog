---
title: 【OSI七层模型】网络部分详解
createTime: 2022/04/09 22:12:01
permalink: /article/rd6ou8q8/
---

视频讲解：个人学习完进行的记录，有点长，但是内容还可以，看完本文有疑问可以留言或看视频解答


[video(video-beKIt9ru-1629977071291)(type-csdn)(url-https://live.csdn.net/v/embed/175897)(image-https://vedu.csdnimg.cn/ad6d1983ad304086a833c8d62543d698/snapshots/2d3a637b147b4e889da8880f290a34bd-00004.jpg)(title-OSI七层协议学习笔记)]


> （忙人们跳过这一段）最近开始啃小林coding的图解网络和图解系统两本书，那么对于网络的学习必定要从底层开始

我们先看一下七层模型图

![](../images/2c4285c95e5e82a88eee615e015cbdbb.png)

前三层是非操作系统开发的同学们通常能接触到的所有东西了，不是这篇文章讲授范畴

**往下到了传输层**，就是TCP和UDP，这里以TCP为例：首先毕竟层数-1了，所以上一层的东西再厉害到我这里也是一视同仁：HTTP数据包在这里变成了TCP数据包的内容，TCP协议又加上了新的头部信息（这里除了端口外，主要表示这是第几个包、包大小等等TCP特有的稳定性保持特性）

这里还加入了源计算机和目标计算机的端口信息，以保证数据到达目标计算机后被正确的应用程序接收。所以，端口虽然经常写在主机地址的后面，但是这已经是两个层的东西了！

（顺便说一句，所谓的TCP稳定连接只是在这一层稳定，到了下一层还是被立刻打散了）

**网络层：开始准备离开这台设备**

在这里我们首先明确一点：每个设备网卡都有一个 `MAC地址` ，这个地址全网唯一；还有一个 `IP地址` ，这个地址处在不同的局域网等环境下是有可能重复的。

那么这里该请出IP协议了。

传输层的TCP协议将HTTP协议的所有内容拆分后每一部分作为了一个TCP数据包的 `正文` ， 再加上一些TCP控制信息作为 `头` 。这里的IP协议也类似，将TCP数据包的所有内容作为一个IP数据包的 `正文` ，并再加上目标计算机的IP地址和这台计算机的IP作为 `头` ，完成后丢给数据链路层

**数据链路层：MAC地址！**

- 最开始全球的电脑连在一个中继器上，每一个数据包都广播给所有电脑，每台电脑根据MAC判断这个数据包是不是自己的
- 后来人们发现这样效率太低，发明了交换机，根据MAC地址找到插在这台交换机上的对应的机器，直接丢给他

如果仍按照上面所述这样的话，那么就代表现在发送数据我只需要MAC？很明显不是，不然就不用发明IP了。上面这个方法的问题在于我不能把多台计算机连接进同一个交换器，就算采用中继的方法也是效率极低的。所以，诞生了公网中唯一的IP。根据IP地址可以计算出目标计算机所处的子网。

数据链路层执行顺序：

（此例中以计算机a向计算机b发送一个tcp包为场景）

 1. 计算机a根据IP包中的目标IP地址（也就是计算机b的IP）查找缓存 `ARP表` 中有没有记录其对应的MAC：如果有直接执行3，否则2

 2.  
	1. 根据子网掩码与目标IP进行与运算，查看目标IP是否与源IP处于同一子网。若处于，则发送ARP包请求目标IP的MAC（结构：谁是 `目标IP` ？请告诉 `源IP` `源MAC` ）。这个包被广播到了当前子网中，因为其包含了计算机a的IP和MAC信息，所以所有人都会在自己的ARP表中加上这一条有关计算机a的缓存；而若是计算机b接收到这条消息，则除此之外还会发出回复，这个回复在发送者处标明了计算机b的IP和MAC，接收者为计算机a的IP和MAC。由于在a发送ARP请求时路由器或交换机也记录了a的MAC与其所处的端口并进行了缓存，所以可以轻松将这个包发送到a那里。
	2. 若不在同一子网，那么计算机a会查找ARP表或发送ARP请求，获取到网关的MAC作为接收者，但是接收者的IP仍是目标IP（毕竟这个在上面的网络层就已经写好了链路层没法改）。

 3. 网关收到了计算机a发出的MAC帧（这是数据链路层的请求包），会解包后（删掉MAC帧前后在数据链路层添加的信息，得到计算机a发出的IP数据包）交给向上一层的网络层。此时网关会查询 `路由表` （大概就是同一子网路由每隔30秒互相报告一下当前有哪些设备连接了自己，这个概念先不细说，我也不太了解怕误导大家），它标记了每个IP段的数据应发送给哪个IP进行下一步转发。于是就将自己的MAC作为源MAC，查询到的下一步要发往的IP的MAC作为目标MAC发出去（如果没有缓存还是先进行一次ARP请求）。

 4. 最终计算机b的网关发现自己记录了计算机b的MAC对应的端口，转发出去，完成通信。（事实上没有任何一个网关知道自己转发到的是另一个网关还是目标计算机，但是目标计算机收到后就会停止转发）

以此类推。

物理层完成光电转换等，完全不是程序员需要关心的了。

---

解疑答惑：

一、 TCP的keep-alive难道不需要一直建立连接？
TCP是传输层协议，只是在传输层看起来连接没有中断，实际上的实现还是要经过底层，就好比点对点传输也要过好几层路由一样。另外，TCP的超时、丢包重传也是在上层发现问题后重新请求包，链路层不知道这个包是否是重传的。

---

参考资料

[几句话让你明白：分析ARP协议、图文拆解交换机/路由器转发原理_DDD_QQQ的博客-CSDN博客](https://blog.csdn.net/DDD_QQQ/article/details/89708022?spm=1001.2014.3001.5506)

[ARP地址解析过程（同一子网和不同子网）_Galip的博客-CSDN博客](https://blog.csdn.net/qq_35646931/article/details/103654157)
